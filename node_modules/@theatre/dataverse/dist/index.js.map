{
  "version": 3,
  "sources": ["../src/index.ts", "../../../node_modules/lodash-es/isArray.js", "../../../node_modules/lodash-es/_freeGlobal.js", "../../../node_modules/lodash-es/_root.js", "../../../node_modules/lodash-es/_Symbol.js", "../../../node_modules/lodash-es/_getRawTag.js", "../../../node_modules/lodash-es/_objectToString.js", "../../../node_modules/lodash-es/_baseGetTag.js", "../../../node_modules/lodash-es/isObjectLike.js", "../../../node_modules/lodash-es/isSymbol.js", "../../../node_modules/lodash-es/_isKey.js", "../../../node_modules/lodash-es/isObject.js", "../../../node_modules/lodash-es/isFunction.js", "../../../node_modules/lodash-es/_coreJsData.js", "../../../node_modules/lodash-es/_isMasked.js", "../../../node_modules/lodash-es/_toSource.js", "../../../node_modules/lodash-es/_baseIsNative.js", "../../../node_modules/lodash-es/_getValue.js", "../../../node_modules/lodash-es/_getNative.js", "../../../node_modules/lodash-es/_nativeCreate.js", "../../../node_modules/lodash-es/_hashClear.js", "../../../node_modules/lodash-es/_hashDelete.js", "../../../node_modules/lodash-es/_hashGet.js", "../../../node_modules/lodash-es/_hashHas.js", "../../../node_modules/lodash-es/_hashSet.js", "../../../node_modules/lodash-es/_Hash.js", "../../../node_modules/lodash-es/_listCacheClear.js", "../../../node_modules/lodash-es/eq.js", "../../../node_modules/lodash-es/_assocIndexOf.js", "../../../node_modules/lodash-es/_listCacheDelete.js", "../../../node_modules/lodash-es/_listCacheGet.js", "../../../node_modules/lodash-es/_listCacheHas.js", "../../../node_modules/lodash-es/_listCacheSet.js", "../../../node_modules/lodash-es/_ListCache.js", "../../../node_modules/lodash-es/_Map.js", "../../../node_modules/lodash-es/_mapCacheClear.js", "../../../node_modules/lodash-es/_isKeyable.js", "../../../node_modules/lodash-es/_getMapData.js", "../../../node_modules/lodash-es/_mapCacheDelete.js", "../../../node_modules/lodash-es/_mapCacheGet.js", "../../../node_modules/lodash-es/_mapCacheHas.js", "../../../node_modules/lodash-es/_mapCacheSet.js", "../../../node_modules/lodash-es/_MapCache.js", "../../../node_modules/lodash-es/memoize.js", "../../../node_modules/lodash-es/_memoizeCapped.js", "../../../node_modules/lodash-es/_stringToPath.js", "../../../node_modules/lodash-es/_arrayMap.js", "../../../node_modules/lodash-es/_baseToString.js", "../../../node_modules/lodash-es/toString.js", "../../../node_modules/lodash-es/_castPath.js", "../../../node_modules/lodash-es/_toKey.js", "../../../node_modules/lodash-es/_baseGet.js", "../../../node_modules/lodash-es/get.js", "../../../node_modules/lodash-es/_overArg.js", "../../../node_modules/lodash-es/_getPrototype.js", "../../../node_modules/lodash-es/isPlainObject.js", "../../../node_modules/lodash-es/last.js", "../src/utils/Tappable.ts", "../src/utils/Emitter.ts", "../src/derivations/DerivationEmitter.ts", "../src/derivations/DerivationValuelessEmitter.ts", "../src/derivations/IDerivation.ts", "../src/derivations/flatMap.ts", "../src/derivations/map.ts", "../src/utils/Stack.ts", "../src/derivations/prism/discoveryMechanism.ts", "../src/derivations/AbstractDerivation.ts", "../src/derivations/DerivationFromSource.ts", "../src/pointer.ts", "../src/utils/updateDeep.ts", "../src/Atom.ts", "../src/Box.ts", "../src/derivations/ConstantDerivation.ts", "../src/derivations/iterateAndCountTicks.ts", "../src/Ticker.ts", "../src/derivations/iterateOver.ts", "../src/derivations/prism/prism.ts", "../src/PointerProxy.ts"],
  "sourcesContent": ["/**\n * The animation-optimized FRP library powering the internals of Theatre.js.\n *\n * @packageDocumentation\n */\n\nexport type {IdentityDerivationProvider} from './Atom'\nexport {default as Atom, val, valueDerivation} from './Atom'\nexport {default as Box} from './Box'\nexport type {IBox} from './Box'\nexport {default as AbstractDerivation} from './derivations/AbstractDerivation'\nexport {default as ConstantDerivation} from './derivations/ConstantDerivation'\nexport {default as DerivationFromSource} from './derivations/DerivationFromSource'\nexport {isDerivation} from './derivations/IDerivation'\nexport type {IDerivation} from './derivations/IDerivation'\nexport {default as iterateAndCountTicks} from './derivations/iterateAndCountTicks'\nexport {default as iterateOver} from './derivations/iterateOver'\nexport {default as prism} from './derivations/prism/prism'\nexport {default as pointer, getPointerParts, isPointer} from './pointer'\nexport type {Pointer, PointerType} from './pointer'\nexport {default as Ticker} from './Ticker'\nexport {default as PointerProxy} from './PointerProxy'\n", "/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nexport default isArray;\n", "/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n", "import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n", "import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n", "import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n", "import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n", "/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n", "import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nexport default isSymbol;\n", "import isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nexport default isKey;\n", "/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n", "import baseGetTag from './_baseGetTag.js';\nimport isObject from './isObject.js';\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nexport default isFunction;\n", "import root from './_root.js';\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nexport default coreJsData;\n", "import coreJsData from './_coreJsData.js';\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nexport default isMasked;\n", "/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nexport default toSource;\n", "import isFunction from './isFunction.js';\nimport isMasked from './_isMasked.js';\nimport isObject from './isObject.js';\nimport toSource from './_toSource.js';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nexport default baseIsNative;\n", "/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nexport default getValue;\n", "import baseIsNative from './_baseIsNative.js';\nimport getValue from './_getValue.js';\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nexport default getNative;\n", "import getNative from './_getNative.js';\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nexport default nativeCreate;\n", "import nativeCreate from './_nativeCreate.js';\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nexport default hashClear;\n", "/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default hashDelete;\n", "import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nexport default hashGet;\n", "import nativeCreate from './_nativeCreate.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nexport default hashHas;\n", "import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nexport default hashSet;\n", "import hashClear from './_hashClear.js';\nimport hashDelete from './_hashDelete.js';\nimport hashGet from './_hashGet.js';\nimport hashHas from './_hashHas.js';\nimport hashSet from './_hashSet.js';\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nexport default Hash;\n", "/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nexport default listCacheClear;\n", "/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nexport default eq;\n", "import eq from './eq.js';\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nexport default assocIndexOf;\n", "import assocIndexOf from './_assocIndexOf.js';\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nexport default listCacheDelete;\n", "import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nexport default listCacheGet;\n", "import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nexport default listCacheHas;\n", "import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nexport default listCacheSet;\n", "import listCacheClear from './_listCacheClear.js';\nimport listCacheDelete from './_listCacheDelete.js';\nimport listCacheGet from './_listCacheGet.js';\nimport listCacheHas from './_listCacheHas.js';\nimport listCacheSet from './_listCacheSet.js';\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nexport default ListCache;\n", "import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nexport default Map;\n", "import Hash from './_Hash.js';\nimport ListCache from './_ListCache.js';\nimport Map from './_Map.js';\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nexport default mapCacheClear;\n", "/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nexport default isKeyable;\n", "import isKeyable from './_isKeyable.js';\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nexport default getMapData;\n", "import getMapData from './_getMapData.js';\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default mapCacheDelete;\n", "import getMapData from './_getMapData.js';\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nexport default mapCacheGet;\n", "import getMapData from './_getMapData.js';\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nexport default mapCacheHas;\n", "import getMapData from './_getMapData.js';\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nexport default mapCacheSet;\n", "import mapCacheClear from './_mapCacheClear.js';\nimport mapCacheDelete from './_mapCacheDelete.js';\nimport mapCacheGet from './_mapCacheGet.js';\nimport mapCacheHas from './_mapCacheHas.js';\nimport mapCacheSet from './_mapCacheSet.js';\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nexport default MapCache;\n", "import MapCache from './_MapCache.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nexport default memoize;\n", "import memoize from './memoize.js';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nexport default memoizeCapped;\n", "import memoizeCapped from './_memoizeCapped.js';\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nexport default stringToPath;\n", "/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nexport default arrayMap;\n", "import Symbol from './_Symbol.js';\nimport arrayMap from './_arrayMap.js';\nimport isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default baseToString;\n", "import baseToString from './_baseToString.js';\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nexport default toString;\n", "import isArray from './isArray.js';\nimport isKey from './_isKey.js';\nimport stringToPath from './_stringToPath.js';\nimport toString from './toString.js';\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nexport default castPath;\n", "import isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default toKey;\n", "import castPath from './_castPath.js';\nimport toKey from './_toKey.js';\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nexport default baseGet;\n", "import baseGet from './_baseGet.js';\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nexport default get;\n", "/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nexport default overArg;\n", "import overArg from './_overArg.js';\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nexport default getPrototype;\n", "import baseGetTag from './_baseGetTag.js';\nimport getPrototype from './_getPrototype.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nexport default isPlainObject;\n", "/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nexport default last;\n", "type Untap = () => void\ntype UntapFromSource = () => void\n\ninterface IProps<V> {\n  tapToSource: (cb: (payload: V) => void) => UntapFromSource\n}\n\ntype Listener<V> = ((v: V) => void) | (() => void)\n\n/**\n * Represents a data-source that can be tapped (subscribed to).\n */\nexport default class Tappable<V> {\n  private _props: IProps<V>\n  private _tappers: Map<number, {bivarianceHack(v: V): void}['bivarianceHack']>\n  private _untapFromSource: null | UntapFromSource\n  private _lastTapperId: number\n  private _untapFromSourceTimeout: null | NodeJS.Timer = null\n\n  constructor(props: IProps<V>) {\n    this._lastTapperId = 0\n    this._untapFromSource = null\n    this._props = props\n    this._tappers = new Map()\n  }\n\n  private _check() {\n    if (this._untapFromSource) {\n      if (this._tappers.size === 0) {\n        this._scheduleToUntapFromSource()\n        /*\n         * this._untapFromSource()\n         * this._untapFromSource = null\n         */\n      }\n    } else {\n      if (this._tappers.size !== 0) {\n        this._untapFromSource = this._props.tapToSource(this._cb)\n      }\n    }\n  }\n\n  private _scheduleToUntapFromSource() {\n    if (this._untapFromSourceTimeout !== null) return\n    this._untapFromSourceTimeout = setTimeout(() => {\n      this._untapFromSourceTimeout = null\n      if (this._tappers.size === 0) {\n        this._untapFromSource!()\n\n        this._untapFromSource = null\n      }\n    }, 0)\n  }\n\n  private _cb: any = (arg: any): void => {\n    for (const cb of this._tappers.values()) {\n      cb(arg)\n    }\n  }\n\n  /**\n   * Tap (subscribe to) the data source.\n   *\n   * @param cb - The callback to be called on a change.\n   */\n  tap(cb: Listener<V>): Untap {\n    const tapperId = this._lastTapperId++\n    this._tappers.set(tapperId, cb)\n    this._check()\n    return () => {\n      this._removeTapperById(tapperId)\n    }\n  }\n\n  /*\n   * tapImmediate(cb: Listener<V>): Untap {\n   *   const ret = this.tap(cb)\n   *   return ret\n   * }\n   */\n\n  private _removeTapperById(id: number) {\n    this._tappers.delete(id)\n    this._check()\n  }\n\n  // /**\n  //  * @deprecated\n  //  */\n  // map<T>(transform: {bivarianceHack(v: V): T}['bivarianceHack']): Tappable<T> {\n  //   return new Tappable({\n  //     tapToSource: (cb: (v: T) => void) => {\n  //       return this.tap((v: $IntentionalAny) => {\n  //         return cb(transform(v))\n  //       })\n  //     },\n  //   })\n  // }\n}\n", "import Tappable from './Tappable'\n\ntype Tapper<V> = (v: V) => void\ntype Untap = () => void\n\n/**\n * An event emitter. Emit events that others can tap (subscribe to).\n */\nexport default class Emitter<V> {\n  private _tappers: Map<any, (v: V) => void>\n  private _lastTapperId: number\n  private _onNumberOfTappersChangeListener: undefined | ((n: number) => void)\n\n  /**\n   * The Tappable associated with this emitter. You can use this to tap (subscribe to) events emitted.\n   */\n  readonly tappable: Tappable<V>\n\n  constructor() {\n    this._lastTapperId = 0\n    this._tappers = new Map()\n    this.tappable = new Tappable({\n      tapToSource: (cb: Tapper<V>) => this._tap(cb),\n    })\n  }\n\n  _tap(cb: Tapper<V>): Untap {\n    const tapperId = this._lastTapperId++\n    this._tappers.set(tapperId, cb)\n    this._onNumberOfTappersChangeListener?.(this._tappers.size)\n    return () => {\n      this._removeTapperById(tapperId)\n    }\n  }\n\n  _removeTapperById(id: number) {\n    const oldSize = this._tappers.size\n    this._tappers.delete(id)\n    const newSize = this._tappers.size\n    if (oldSize !== newSize) {\n      this._onNumberOfTappersChangeListener?.(newSize)\n    }\n  }\n\n  /**\n   * Emit a value.\n   *\n   * @param payload - The value to be emitted.\n   */\n  emit(payload: V) {\n    for (const cb of this._tappers.values()) {\n      cb(payload)\n    }\n  }\n\n  /**\n   * Checks whether the emitter has tappers (subscribers).\n   */\n  hasTappers() {\n    return this._tappers.size !== 0\n  }\n\n  /**\n   * Calls callback when the number of tappers (subscribers) changes.\n   *\n   * @example\n   * ```ts\n   * emitter.onNumberOfTappersChange((n) => {\n   *   console.log(\"number of tappers changed:\", n)\n   * })\n   * ```\n   */\n  onNumberOfTappersChange(cb: (n: number) => void) {\n    this._onNumberOfTappersChangeListener = cb\n  }\n}\n", "import type Ticker from '../Ticker'\nimport Emitter from '../utils/Emitter'\nimport type {default as Tappable} from '../utils/Tappable'\nimport type {IDerivation} from './IDerivation'\n\n/**\n * An event emitter that emits events on changes to a derivation.\n */\nexport default class DerivationEmitter<V> {\n  private _derivation: IDerivation<V>\n  private _ticker: Ticker\n  private _emitter: Emitter<V>\n  private _lastValue: undefined | V\n  private _lastValueRecorded: boolean\n  private _hadTappers: boolean\n\n  /**\n   * @param derivation - The derivation to emit events for.\n   * @param ticker - The ticker to use to batch events.\n   */\n  constructor(derivation: IDerivation<V>, ticker: Ticker) {\n    this._derivation = derivation\n    this._ticker = ticker\n    this._emitter = new Emitter()\n    this._emitter.onNumberOfTappersChange(() => {\n      this._reactToNumberOfTappersChange()\n    })\n    this._hadTappers = false\n    this._lastValueRecorded = false\n    this._lastValue = undefined\n    return this\n  }\n\n  private _possiblyMarkAsStale = () => {\n    this._ticker.onThisOrNextTick(this._refresh)\n  }\n\n  private _reactToNumberOfTappersChange() {\n    const hasTappers = this._emitter.hasTappers()\n    if (hasTappers !== this._hadTappers) {\n      this._hadTappers = hasTappers\n      if (hasTappers) {\n        this._derivation.addDependent(this._possiblyMarkAsStale)\n      } else {\n        this._derivation.removeDependent(this._possiblyMarkAsStale)\n      }\n    }\n  }\n\n  /**\n   * The tappable associated with the emitter. You can use it to tap (subscribe to) the underlying derivation.\n   */\n  tappable(): Tappable<V> {\n    return this._emitter.tappable\n  }\n\n  private _refresh = () => {\n    const newValue = this._derivation.getValue()\n    if (newValue === this._lastValue && this._lastValueRecorded === true) return\n    this._lastValue = newValue\n    this._lastValueRecorded = true\n    this._emitter.emit(newValue)\n  }\n}\n", "import Emitter from '../utils/Emitter'\nimport type {default as Tappable} from '../utils/Tappable'\nimport type {IDerivation} from './IDerivation'\n\n/**\n * Like DerivationEmitter, but with a different performance model. DerivationValuelessEmitter emits every time the\n * derivation is updated, even if the value didn't change, and tappers are called without the value. The advantage of\n * this is that you have control over when the underlying derivation is freshened, it won't automatically be freshened\n * by the emitter.\n */\nexport default class DerivationValuelessEmitter<V> {\n  _derivation: IDerivation<V>\n  _emitter: Emitter<void>\n  _hadTappers: boolean\n\n  constructor(\n    derivation: IDerivation<V>,\n    readonly dontEmitValues: boolean = false,\n  ) {\n    this._derivation = derivation\n    this._emitter = new Emitter()\n    this._emitter.onNumberOfTappersChange(() => {\n      this._reactToNumberOfTappersChange()\n    })\n    this._hadTappers = false\n    return this\n  }\n\n  private _possiblyMarkAsStale = () => {\n    this._emitter.emit(undefined)\n  }\n\n  _reactToNumberOfTappersChange() {\n    const hasTappers = this._emitter.hasTappers()\n    if (hasTappers !== this._hadTappers) {\n      this._hadTappers = hasTappers\n      if (hasTappers) {\n        this._derivation.addDependent(this._possiblyMarkAsStale)\n      } else {\n        this._derivation.removeDependent(this._possiblyMarkAsStale)\n      }\n    }\n  }\n\n  /**\n   * The tappable associated with the emitter. You can use it to tap (subscribe to) the underlying derivation.\n   */\n  tappable(): Tappable<void> {\n    return this._emitter.tappable\n  }\n}\n", "import type Ticker from '../Ticker'\nimport type {$IntentionalAny, VoidFn} from '../types'\nimport type Tappable from '../utils/Tappable'\n\ntype IDependent = (msgComingFrom: IDerivation<$IntentionalAny>) => void\n\n/**\n * Common interface for derivations.\n */\nexport interface IDerivation<V> {\n  /**\n   * Whether the object is a derivation.\n   */\n  isDerivation: true\n\n  /**\n   * Whether the derivation is hot.\n   */\n  isHot: boolean\n\n  /**\n   * Returns a `Tappable` of the changes of this derivation.\n   */\n  changes(ticker: Ticker): Tappable<V>\n\n  /**\n   * Like {@link changes} but with a different performance model. `changesWithoutValues` returns a {@link Tappable} that\n   * updates every time the derivation is updated, even if the value didn't change, and the callback is called without\n   * the value. The advantage of this is that you have control over when the derivation is freshened, it won't\n   * automatically be kept fresh.\n   */\n  changesWithoutValues(): Tappable<void>\n\n  /**\n   * Keep the derivation hot, even if there are no tappers (subscribers).\n   */\n  keepHot(): VoidFn\n\n  /**\n   * Convenience method that taps (subscribes to) the derivation using `this.changes(ticker).tap(fn)` and immediately calls\n   * the callback with the current value.\n   *\n   * @param ticker - The ticker to use for batching.\n   * @param fn - The callback to call on update.\n   *\n   * @see changes\n   */\n  tapImmediate(ticker: Ticker, fn: (cb: V) => void): VoidFn\n\n  /**\n   * Add a derivation as a dependent of this derivation.\n   *\n   * @param d - The derivation to be made a dependent of this derivation.\n   *\n   * @see removeDependent\n   */\n  addDependent(d: IDependent): void\n\n  /**\n   * Remove a derivation as a dependent of this derivation.\n   *\n   * @param d - The derivation to be removed from as a dependent of this derivation.\n   *\n   * @see addDependent\n   */\n  removeDependent(d: IDependent): void\n\n  /**\n   * Gets the current value of the derivation. If the value is stale, it causes the derivation to freshen.\n   */\n  getValue(): V\n\n  /**\n   * Creates a new derivation from this derivation using the provided mapping function. The new derivation's value will be\n   * `fn(thisDerivation.getValue())`.\n   *\n   * @param fn - The mapping function to use. Note: it accepts a plain value, not a derivation.\n   */\n  map<T>(fn: (v: V) => T): IDerivation<T>\n\n  /**\n   * Same as {@link IDerivation.map}, but the mapping function can also return a derivation, in which case the derivation returned\n   * by `flatMap` takes the value of that derivation.\n   *\n   * @example\n   * ```ts\n   * // Simply using map() here would return the inner derivation when we call getValue()\n   * new Box(3).derivation.map((value) => new Box(value).derivation).getValue()\n   *\n   * // Using flatMap() eliminates the inner derivation\n   * new Box(3).derivation.flatMap((value) => new Box(value).derivation).getValue()\n   * ```\n   *\n   * @param fn - The mapping function to use. Note: it accepts a plain value, not a derivation.\n   */\n  flatMap<R>(\n    fn: (v: V) => R,\n  ): IDerivation<R extends IDerivation<infer T> ? T : R>\n}\n\n/**\n * Returns whether `d` is a derivation.\n */\nexport function isDerivation(d: any): d is IDerivation<unknown> {\n  return d && d.isDerivation && d.isDerivation === true\n}\n", "import type {$FixMe} from '../types'\nimport AbstractDerivation from './AbstractDerivation'\nimport type {IDerivation} from './IDerivation'\nimport {isDerivation} from './IDerivation'\n\nenum UPDATE_NEEDED_FROM {\n  none = 0,\n  dep = 1,\n  inner = 2,\n}\n\nconst makeFlatMapDerivationClass = () => {\n  class FlatMapDerivation<V, DepType> extends AbstractDerivation<V> {\n    private _innerDerivation: undefined | null | IDerivation<V>\n    private _staleDependency: UPDATE_NEEDED_FROM\n\n    static displayName = 'flatMap'\n\n    constructor(\n      readonly _depDerivation: IDerivation<DepType>,\n      readonly _fn: (v: DepType) => IDerivation<V> | V,\n    ) {\n      super()\n      this._innerDerivation = undefined\n      this._staleDependency = UPDATE_NEEDED_FROM.dep\n\n      this._addDependency(_depDerivation)\n\n      return this\n    }\n\n    _recalculateHot() {\n      const updateNeededFrom = this._staleDependency\n      this._staleDependency = UPDATE_NEEDED_FROM.none\n\n      if (updateNeededFrom === UPDATE_NEEDED_FROM.inner) {\n        // @ts-ignore\n        return this._innerDerivation.getValue()\n      }\n\n      const possibleInnerDerivation = this._fn(this._depDerivation.getValue())\n\n      if (isDerivation(possibleInnerDerivation)) {\n        this._innerDerivation = possibleInnerDerivation\n        this._addDependency(possibleInnerDerivation)\n        return possibleInnerDerivation.getValue()\n      } else {\n        return possibleInnerDerivation\n      }\n    }\n\n    protected _recalculateCold() {\n      const possibleInnerDerivation = this._fn(this._depDerivation.getValue())\n\n      if (isDerivation(possibleInnerDerivation)) {\n        return possibleInnerDerivation.getValue()\n      } else {\n        return possibleInnerDerivation\n      }\n    }\n\n    protected _recalculate() {\n      return this.isHot ? this._recalculateHot() : this._recalculateCold()\n    }\n\n    protected _reactToDependencyBecomingStale(\n      msgComingFrom: IDerivation<unknown>,\n    ) {\n      const updateNeededFrom =\n        msgComingFrom === this._depDerivation\n          ? UPDATE_NEEDED_FROM.dep\n          : UPDATE_NEEDED_FROM.inner\n\n      if (\n        updateNeededFrom === UPDATE_NEEDED_FROM.inner &&\n        msgComingFrom !== this._innerDerivation\n      ) {\n        throw Error(\n          `got a _reactToDependencyBecomingStale() from neither the dep nor the inner derivation`,\n        )\n      }\n\n      if (this._staleDependency === UPDATE_NEEDED_FROM.none) {\n        this._staleDependency = updateNeededFrom\n\n        if (updateNeededFrom === UPDATE_NEEDED_FROM.dep) {\n          this._removeInnerDerivation()\n        }\n      } else if (this._staleDependency === UPDATE_NEEDED_FROM.dep) {\n      } else {\n        if (updateNeededFrom === UPDATE_NEEDED_FROM.dep) {\n          this._staleDependency = UPDATE_NEEDED_FROM.dep\n          this._removeInnerDerivation()\n        }\n      }\n    }\n\n    private _removeInnerDerivation() {\n      if (this._innerDerivation) {\n        this._removeDependency(this._innerDerivation)\n        this._innerDerivation = undefined\n      }\n    }\n\n    protected _keepHot() {\n      this._staleDependency = UPDATE_NEEDED_FROM.dep\n      this.getValue()\n    }\n\n    protected _becomeCold() {\n      this._staleDependency = UPDATE_NEEDED_FROM.dep\n      this._removeInnerDerivation()\n    }\n  }\n  return FlatMapDerivation\n}\n\nlet cls: ReturnType<typeof makeFlatMapDerivationClass> | undefined = undefined\n\nexport default function flatMap<V, R>(\n  dep: IDerivation<V>,\n  fn: (v: V) => R,\n): IDerivation<R extends IDerivation<infer T> ? T : R> {\n  if (!cls) {\n    cls = makeFlatMapDerivationClass()\n  }\n  return new cls(dep, fn) as $FixMe\n}\n", "import AbstractDerivation from './AbstractDerivation'\nimport type {IDerivation} from './IDerivation'\n\n// Exporting from a function because of the circular dependency with AbstractDerivation\nconst makeMapDerivationClass = () =>\n  class MapDerivation<T, V> extends AbstractDerivation<V> {\n    constructor(\n      private readonly _dep: IDerivation<T>,\n      private readonly _fn: (t: T) => V,\n    ) {\n      super()\n      this._addDependency(_dep)\n    }\n\n    _recalculate() {\n      return this._fn(this._dep.getValue())\n    }\n\n    _reactToDependencyBecomingStale() {}\n  }\n\nlet cls: ReturnType<typeof makeMapDerivationClass> | undefined = undefined\n\nexport default function flatMap<V, R>(\n  dep: IDerivation<V>,\n  fn: (v: V) => R,\n): IDerivation<R> {\n  if (!cls) {\n    cls = makeMapDerivationClass()\n  }\n  return new cls(dep, fn)\n}\n", "interface Node<Data> {\n  next: undefined | Node<Data>\n  data: Data\n}\n\n/**\n * Just a simple LinkedList\n */\nexport default class Stack<Data> {\n  _head: undefined | Node<Data>\n\n  constructor() {\n    this._head = undefined\n  }\n\n  peek() {\n    return this._head && this._head.data\n  }\n\n  pop() {\n    const head = this._head\n    if (!head) {\n      return undefined\n    }\n    this._head = head.next\n    return head.data\n  }\n\n  push(data: Data) {\n    const node = {next: this._head, data}\n    this._head = node\n  }\n}\n", "import type {$IntentionalAny} from '../../types'\nimport Stack from '../../utils/Stack'\nimport type {IDerivation} from '../IDerivation'\n\nfunction createMechanism() {\n  const noop = () => {}\n\n  const stack = new Stack<Collector>()\n  const noopCollector: Collector = noop\n\n  type Collector = (d: IDerivation<$IntentionalAny>) => void\n\n  const pushCollector = (collector: Collector): void => {\n    stack.push(collector)\n  }\n\n  const popCollector = (collector: Collector): void => {\n    const existing = stack.peek()\n    if (existing !== collector) {\n      throw new Error(`Popped collector is not on top of the stack`)\n    }\n    stack.pop()\n  }\n\n  const startIgnoringDependencies = () => {\n    stack.push(noopCollector)\n  }\n\n  const stopIgnoringDependencies = () => {\n    if (stack.peek() !== noopCollector) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn('This should never happen')\n      }\n    } else {\n      stack.pop()\n    }\n  }\n\n  const reportResolutionStart = (d: IDerivation<$IntentionalAny>) => {\n    const possibleCollector = stack.peek()\n    if (possibleCollector) {\n      possibleCollector(d)\n    }\n\n    stack.push(noopCollector)\n  }\n\n  const reportResolutionEnd = (_d: IDerivation<$IntentionalAny>) => {\n    stack.pop()\n  }\n\n  return {\n    type: 'Dataverse_discoveryMechanism' as 'Dataverse_discoveryMechanism',\n    startIgnoringDependencies,\n    stopIgnoringDependencies,\n    reportResolutionStart,\n    reportResolutionEnd,\n    pushCollector,\n    popCollector,\n  }\n}\n\nfunction getSharedMechanism(): ReturnType<typeof createMechanism> {\n  const varName = '__dataverse_discoveryMechanism_sharedStack'\n  const root =\n    typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {}\n  if (root) {\n    const existingMechanism: ReturnType<typeof createMechanism> | undefined =\n      // @ts-ignore ignore\n      root[varName]\n    if (\n      existingMechanism &&\n      typeof existingMechanism === 'object' &&\n      existingMechanism.type === 'Dataverse_discoveryMechanism'\n    ) {\n      return existingMechanism\n    } else {\n      const mechanism = createMechanism()\n      // @ts-ignore ignore\n      root[varName] = mechanism\n      return mechanism\n    }\n  } else {\n    return createMechanism()\n  }\n}\n\nexport const {\n  startIgnoringDependencies,\n  stopIgnoringDependencies,\n  reportResolutionEnd,\n  reportResolutionStart,\n  pushCollector,\n  popCollector,\n} = getSharedMechanism()\n", "import type Ticker from '../Ticker'\nimport type {$IntentionalAny, VoidFn} from '../types'\nimport type Tappable from '../utils/Tappable'\nimport DerivationEmitter from './DerivationEmitter'\nimport DerivationValuelessEmitter from './DerivationValuelessEmitter'\nimport flatMap from './flatMap'\nimport type {IDerivation} from './IDerivation'\nimport map from './map'\nimport {\n  reportResolutionEnd,\n  reportResolutionStart,\n} from './prism/discoveryMechanism'\n\ntype IDependent = (msgComingFrom: IDerivation<$IntentionalAny>) => void\n\n/**\n * Represents a derivation whose changes can be tracked. To be used as the base class for all derivations.\n */\nexport default abstract class AbstractDerivation<V> implements IDerivation<V> {\n  /**\n   * Whether the object is a derivation.\n   */\n  readonly isDerivation: true = true\n  private _didMarkDependentsAsStale: boolean = false\n  private _isHot: boolean = false\n\n  private _isFresh: boolean = false\n\n  /**\n   * @internal\n   */\n  protected _lastValue: undefined | V = undefined\n\n  /**\n   * @internal\n   */\n  protected _dependents: Set<IDependent> = new Set()\n\n  /**\n   * @internal\n   */\n  protected _dependencies: Set<IDerivation<$IntentionalAny>> = new Set()\n\n  /**\n   * @internal\n   */\n  protected abstract _recalculate(): V\n\n  /**\n   * @internal\n   */\n  protected abstract _reactToDependencyBecomingStale(\n    which: IDerivation<unknown>,\n  ): void\n\n  constructor() {}\n\n  /**\n   * Whether the derivation is hot.\n   */\n  get isHot(): boolean {\n    return this._isHot\n  }\n\n  /**\n   * @internal\n   */\n  protected _addDependency(d: IDerivation<$IntentionalAny>) {\n    if (this._dependencies.has(d)) return\n    this._dependencies.add(d)\n    if (this._isHot) d.addDependent(this._internal_markAsStale)\n  }\n\n  /**\n   * @internal\n   */\n  protected _removeDependency(d: IDerivation<$IntentionalAny>) {\n    if (!this._dependencies.has(d)) return\n    this._dependencies.delete(d)\n    if (this._isHot) d.removeDependent(this._internal_markAsStale)\n  }\n\n  /**\n   * Returns a `Tappable` of the changes of this derivation.\n   */\n  changes(ticker: Ticker): Tappable<V> {\n    return new DerivationEmitter(this, ticker).tappable()\n  }\n\n  /**\n   * Like {@link AbstractDerivation.changes} but with a different performance model. `changesWithoutValues` returns a `Tappable` that\n   * updates every time the derivation is updated, even if the value didn't change, and the callback is called without\n   * the value. The advantage of this is that you have control over when the derivation is freshened, it won't\n   * automatically be kept fresh.\n   */\n  changesWithoutValues(): Tappable<void> {\n    return new DerivationValuelessEmitter(this).tappable()\n  }\n\n  /**\n   * Keep the derivation hot, even if there are no tappers (subscribers).\n   */\n  keepHot() {\n    return this.changesWithoutValues().tap(() => {})\n  }\n\n  /**\n   * Convenience method that taps (subscribes to) the derivation using `this.changes(ticker).tap(fn)` and immediately calls\n   * the callback with the current value.\n   *\n   * @param ticker - The ticker to use for batching.\n   * @param fn - The callback to call on update.\n   *\n   * @see changes\n   */\n  tapImmediate(ticker: Ticker, fn: (cb: V) => void): VoidFn {\n    const untap = this.changes(ticker).tap(fn)\n    fn(this.getValue())\n    return untap\n  }\n\n  /**\n   * Add a derivation as a dependent of this derivation.\n   *\n   * @param d - The derivation to be made a dependent of this derivation.\n   *\n   * @see removeDependent\n   */\n  // TODO: document this better, what are dependents?\n  addDependent(d: IDependent) {\n    const hadDepsBefore = this._dependents.size > 0\n    this._dependents.add(d)\n    const hasDepsNow = this._dependents.size > 0\n    if (hadDepsBefore !== hasDepsNow) {\n      this._reactToNumberOfDependentsChange()\n    }\n  }\n\n  /**\n   * Remove a derivation as a dependent of this derivation.\n   *\n   * @param d - The derivation to be removed from as a dependent of this derivation.\n   *\n   * @see addDependent\n   */\n  removeDependent(d: IDependent) {\n    const hadDepsBefore = this._dependents.size > 0\n    this._dependents.delete(d)\n    const hasDepsNow = this._dependents.size > 0\n    if (hadDepsBefore !== hasDepsNow) {\n      this._reactToNumberOfDependentsChange()\n    }\n  }\n\n  /**\n   * This is meant to be called by subclasses\n   *\n   * @sealed\n   * @internal\n   */\n  protected _markAsStale(which: IDerivation<$IntentionalAny>) {\n    this._internal_markAsStale(which)\n  }\n\n  private _internal_markAsStale = (which: IDerivation<$IntentionalAny>) => {\n    this._reactToDependencyBecomingStale(which)\n\n    if (this._didMarkDependentsAsStale) return\n\n    this._didMarkDependentsAsStale = true\n    this._isFresh = false\n\n    for (const dependent of this._dependents) {\n      dependent(this)\n    }\n  }\n\n  /**\n   * Gets the current value of the derivation. If the value is stale, it causes the derivation to freshen.\n   */\n  getValue(): V {\n    /**\n     * TODO We should prevent (or warn about) a common mistake users make, which is reading the value of\n     * a derivation in the body of a react component (e.g. `der.getValue()` (often via `val()`) instead of `useVal()`\n     * or `uesPrism()`).\n     *\n     * Although that's the most common example of this mistake, you can also find it outside of react components.\n     * Basically the user runs `der.getValue()` assuming the read is detected by a wrapping prism when it's not.\n     *\n     * Sometiems the derivation isn't even hot when the user assumes it is.\n     *\n     * We can fix this type of mistake by:\n     * 1. Warning the user when they call `getValue()` on a cold derivation.\n     * 2. Warning the user about calling `getValue()` on a hot-but-stale derivation\n     *    if `getValue()` isn't called by a known mechanism like a `DerivationEmitter`.\n     *\n     * Design constraints:\n     * - This fix should not have a perf-penalty in production. Perhaps use a global flag + `process.env.NODE_ENV !== 'production'`\n     *   to enable it.\n     * - In the case of `DerivationValuelessEmitter`, we don't control when the user calls\n     *   `getValue()` (as opposed to `DerivationEmitter` which calls `getValue()` directly).\n     *   Perhaps we can disable the check in that case.\n     * - Probably the best place to add this check is right here in this method plus some changes to `reportResulutionStart()`,\n     *   which would have to be changed to let the caller know if there is an actual collector (a prism)\n     *   present in its stack.\n     */\n    reportResolutionStart(this)\n\n    if (!this._isFresh) {\n      const newValue = this._recalculate()\n      this._lastValue = newValue\n      if (this._isHot) {\n        this._isFresh = true\n        this._didMarkDependentsAsStale = false\n      }\n    }\n\n    reportResolutionEnd(this)\n    return this._lastValue!\n  }\n\n  private _reactToNumberOfDependentsChange() {\n    const shouldBecomeHot = this._dependents.size > 0\n\n    if (shouldBecomeHot === this._isHot) return\n\n    this._isHot = shouldBecomeHot\n    this._didMarkDependentsAsStale = false\n    this._isFresh = false\n    if (shouldBecomeHot) {\n      for (const d of this._dependencies) {\n        d.addDependent(this._internal_markAsStale)\n      }\n      this._keepHot()\n    } else {\n      for (const d of this._dependencies) {\n        d.removeDependent(this._internal_markAsStale)\n      }\n      this._becomeCold()\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected _keepHot() {}\n\n  /**\n   * @internal\n   */\n  protected _becomeCold() {}\n\n  /**\n   * Creates a new derivation from this derivation using the provided mapping function. The new derivation's value will be\n   * `fn(thisDerivation.getValue())`.\n   *\n   * @param fn - The mapping function to use. Note: it accepts a plain value, not a derivation.\n   */\n  map<T>(fn: (v: V) => T): IDerivation<T> {\n    return map(this, fn)\n  }\n\n  /**\n   * Same as {@link AbstractDerivation.map}, but the mapping function can also return a derivation, in which case the derivation returned\n   * by `flatMap` takes the value of that derivation.\n   *\n   * @example\n   * ```ts\n   * // Simply using map() here would return the inner derivation when we call getValue()\n   * new Box(3).derivation.map((value) => new Box(value).derivation).getValue()\n   *\n   * // Using flatMap() eliminates the inner derivation\n   * new Box(3).derivation.flatMap((value) => new Box(value).derivation).getValue()\n   * ```\n   *\n   * @param fn - The mapping function to use. Note: it accepts a plain value, not a derivation.\n   */\n  flatMap<R>(\n    fn: (v: V) => R,\n  ): IDerivation<R extends IDerivation<infer T> ? T : R> {\n    return flatMap(this, fn)\n  }\n}\n", "import type {VoidFn} from '../types'\nimport AbstractDerivation from './AbstractDerivation'\n\nconst noop = () => {}\n\n/**\n * Represents a derivation based on a tappable (subscribable) data source.\n */\nexport default class DerivationFromSource<V> extends AbstractDerivation<V> {\n  private _untapFromChanges: () => void\n  private _cachedValue: undefined | V\n  private _hasCachedValue: boolean\n\n  /**\n   * @param _tapToSource - A function that takes a listener and subscribes it to the underlying data source.\n   * @param _getValueFromSource - A function that returns the current value of the data source.\n   */\n  constructor(\n    private readonly _tapToSource: (listener: (newValue: V) => void) => VoidFn,\n    private readonly _getValueFromSource: () => V,\n  ) {\n    super()\n    this._untapFromChanges = noop\n    this._cachedValue = undefined\n    this._hasCachedValue = false\n  }\n\n  /**\n   * @internal\n   */\n  _recalculate() {\n    if (this.isHot) {\n      if (!this._hasCachedValue) {\n        this._cachedValue = this._getValueFromSource()\n        this._hasCachedValue = true\n      }\n      return this._cachedValue as V\n    } else {\n      return this._getValueFromSource()\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _keepHot() {\n    this._hasCachedValue = false\n    this._cachedValue = undefined\n\n    this._untapFromChanges = this._tapToSource((newValue) => {\n      this._hasCachedValue = true\n      this._cachedValue = newValue\n      this._markAsStale(this)\n    })\n  }\n\n  /**\n   * @internal\n   */\n  _becomeCold() {\n    this._untapFromChanges()\n    this._untapFromChanges = noop\n\n    this._hasCachedValue = false\n    this._cachedValue = undefined\n  }\n\n  /**\n   * @internal\n   */\n  _reactToDependencyBecomingStale() {}\n}\n", "import type {$IntentionalAny} from './types'\n\ntype PathToProp = Array<string | number>\n\ntype PointerMeta = {\n  root: {}\n  path: (string | number)[]\n}\n\n/** We are using an empty object as a WeakMap key for storing pointer meta data */\ntype WeakPointerKey = {}\n\nexport type UnindexableTypesForPointer =\n  | number\n  | string\n  | boolean\n  | null\n  | void\n  | undefined\n  | Function // eslint-disable-line @typescript-eslint/ban-types\n\nexport type UnindexablePointer = {\n  [K in $IntentionalAny]: Pointer<undefined>\n}\n\nconst pointerMetaWeakMap = new WeakMap<WeakPointerKey, PointerMeta>()\nconst cachedSubPathPointersWeakMap = new WeakMap<\n  WeakPointerKey,\n  Map<string | number, Pointer<unknown>>\n>()\n\n/**\n * A wrapper type for the type a `Pointer` points to.\n */\nexport type PointerType<O> = {\n  /**\n   * Only accessible via the type system.\n   * This is a helper for getting the underlying pointer type\n   * via the type space.\n   */\n  $$__pointer_type: O\n}\n\n/**\n * The type of {@link Atom} pointers. See {@link pointer|pointer()} for an\n * explanation of pointers.\n *\n * @see Atom\n *\n * @remarks\n * The Pointer type is quite tricky because it doesn't play well with `any` and other inexact types.\n * Here is an example that one would expect to work, but currently doesn't:\n * ```ts\n * declare function expectAnyPointer(pointer: Pointer<any>): void\n *\n * expectAnyPointer(null as Pointer<{}>) // this shows as a type error because Pointer<{}> is not assignable to Pointer<any>, even though it should\n * ```\n *\n * The current solution is to just avoid using `any` with pointer-related code (or type-test it well).\n * But if you enjoy solving typescript puzzles, consider fixing this :)\n * Potentially, [TypeScript variance annotations in 4.7+](https://devblogs.microsoft.com/typescript/announcing-typescript-4-7-beta/#optional-variance-annotations-for-type-parameters)\n * might be able to help us.\n */\nexport type Pointer<O> = PointerType<O> &\n  // `Exclude<O, undefined>` will remove `undefined` from the first type\n  // `undefined extends O ? undefined : never` will give us `undefined` if `O` is `... | undefined`\n  PointerInner<Exclude<O, undefined>, undefined extends O ? undefined : never>\n\n// By separating the `O` (non-undefined) from the `undefined` or `never`, we\n// can properly use `O extends ...` to determine the kind of potential value\n// without actually discarding optionality information.\ntype PointerInner<O, Optional> = O extends UnindexableTypesForPointer\n  ? UnindexablePointer\n  : unknown extends O\n  ? UnindexablePointer\n  : O extends (infer T)[]\n  ? Pointer<T>[]\n  : O extends {}\n  ? {\n      [K in keyof O]-?: Pointer<O[K] | Optional>\n    }\n  : UnindexablePointer\n\nconst pointerMetaSymbol = Symbol('pointerMeta')\n\nconst proxyHandler = {\n  get(\n    pointerKey: WeakPointerKey,\n    prop: string | typeof pointerMetaSymbol,\n  ): $IntentionalAny {\n    if (prop === pointerMetaSymbol) return pointerMetaWeakMap.get(pointerKey)!\n\n    let subPathPointers = cachedSubPathPointersWeakMap.get(pointerKey)\n    if (!subPathPointers) {\n      subPathPointers = new Map()\n      cachedSubPathPointersWeakMap.set(pointerKey, subPathPointers)\n    }\n\n    const existing = subPathPointers.get(prop)\n    if (existing !== undefined) return existing\n\n    const meta = pointerMetaWeakMap.get(pointerKey)!\n\n    const subPointer = pointer({root: meta.root, path: [...meta.path, prop]})\n    subPathPointers.set(prop, subPointer)\n    return subPointer\n  },\n}\n\n/**\n * Returns the metadata associated with the pointer. Usually the root object and\n * the path.\n *\n * @param p - The pointer.\n */\nexport const getPointerMeta = <_>(p: PointerType<_>): PointerMeta => {\n  // @ts-ignore @todo\n  const meta: PointerMeta = p[\n    pointerMetaSymbol as unknown as $IntentionalAny\n  ] as $IntentionalAny\n  return meta\n}\n\n/**\n * Returns the root object and the path of the pointer.\n *\n * @example\n * ```ts\n * const {root, path} = getPointerParts(pointer)\n * ```\n *\n * @param p - The pointer.\n *\n * @returns An object with two properties: `root`-the root object or the pointer, and `path`-the path of the pointer. `path` is an array of the property-chain.\n */\nexport const getPointerParts = <_>(\n  p: Pointer<_>,\n): {root: {}; path: PathToProp} => {\n  const {root, path} = getPointerMeta(p)\n  return {root, path}\n}\n\n/**\n * Creates a pointer to a (nested) property of an {@link Atom}.\n *\n * @remarks\n * Pointers are used to make derivations of properties or nested properties of\n * {@link Atom|Atoms}.\n *\n * Pointers also allow easy construction of new pointers pointing to nested members\n * of the root object, by simply using property chaining. E.g. `somePointer.a.b` will\n * create a new pointer that has `'a'` and `'b'` added to the path of `somePointer`.\n *\n * @example\n * ```ts\n * // Here, sum is a derivation that updates whenever the a or b prop of someAtom does.\n * const sum = prism(() => {\n *   return val(pointer({root: someAtom, path: ['a']})) + val(pointer({root: someAtom, path: ['b']}));\n * });\n *\n * // Note, atoms have a convenience Atom.pointer property that points to the root,\n * // which you would normally use in this situation.\n * const sum = prism(() => {\n *   return val(someAtom.pointer.a) + val(someAtom.pointer.b);\n * });\n * ```\n *\n * @param args - The pointer parameters.\n *\n * @typeParam O - The type of the value being pointed to.\n */\nfunction pointer<O>(args: {root: {}; path?: Array<string | number>}) {\n  const meta: PointerMeta = {\n    root: args.root as $IntentionalAny,\n    path: args.path ?? [],\n  }\n  const pointerKey: WeakPointerKey = {}\n  pointerMetaWeakMap.set(pointerKey, meta)\n  return new Proxy(pointerKey, proxyHandler) as Pointer<O>\n}\n\nexport default pointer\n\n/**\n * Returns whether `p` is a pointer.\n */\nexport const isPointer = (p: $IntentionalAny): p is Pointer<unknown> => {\n  return p && !!getPointerMeta(p)\n}\n", "import type {$FixMe, $IntentionalAny} from '../types'\n\nexport default function updateDeep<S>(\n  state: S,\n  path: (string | number | undefined)[],\n  reducer: (...args: $IntentionalAny[]) => $IntentionalAny,\n): S {\n  if (path.length === 0) return reducer(state)\n  return hoop(state, path as $IntentionalAny, reducer)\n}\n\nconst hoop = (\n  s: $FixMe,\n  path: (string | number)[],\n  reducer: $FixMe,\n): $FixMe => {\n  if (path.length === 0) {\n    return reducer(s)\n  }\n  if (Array.isArray(s)) {\n    let [index, ...restOfPath] = path\n    index = parseInt(String(index), 10)\n    if (isNaN(index)) index = 0\n    const oldVal = s[index]\n    const newVal = hoop(oldVal, restOfPath, reducer)\n    if (oldVal === newVal) return s\n    const newS = [...s]\n    newS.splice(index, 1, newVal)\n    return newS\n  } else if (typeof s === 'object' && s !== null) {\n    const [key, ...restOfPath] = path\n    const oldVal = s[key]\n    const newVal = hoop(oldVal, restOfPath, reducer)\n    if (oldVal === newVal) return s\n    const newS = {...s, [key]: newVal}\n    return newS\n  } else {\n    const [key, ...restOfPath] = path\n\n    return {[key]: hoop(undefined, restOfPath, reducer)}\n  }\n}\n", "import get from 'lodash-es/get'\nimport isPlainObject from 'lodash-es/isPlainObject'\nimport last from 'lodash-es/last'\nimport DerivationFromSource from './derivations/DerivationFromSource'\nimport type {IDerivation} from './derivations/IDerivation'\nimport {isDerivation} from './derivations/IDerivation'\nimport type {Pointer, PointerType} from './pointer'\nimport {isPointer} from './pointer'\nimport pointer, {getPointerMeta} from './pointer'\nimport type {$FixMe, $IntentionalAny} from './types'\nimport type {PathBasedReducer} from './utils/PathBasedReducer'\nimport updateDeep from './utils/updateDeep'\n\ntype Listener = (newVal: unknown) => void\n\nenum ValueTypes {\n  Dict,\n  Array,\n  Other,\n}\n\n/**\n * Interface for objects that can provide a derivation at a certain path.\n */\nexport interface IdentityDerivationProvider {\n  /**\n   * @internal\n   * Future: We could consider using a `Symbol.for(\"dataverse/IdentityDerivationProvider\")` as a key here, similar to\n   * how {@link Iterable} works for `of`.\n   */\n  readonly $$isIdentityDerivationProvider: true\n  /**\n   * Returns a derivation of the value at the provided path.\n   *\n   * @param path - The path to create the derivation at.\n   */\n  getIdentityDerivation(path: Array<string | number>): IDerivation<unknown>\n}\n\nconst getTypeOfValue = (v: unknown): ValueTypes => {\n  if (Array.isArray(v)) return ValueTypes.Array\n  if (isPlainObject(v)) return ValueTypes.Dict\n  return ValueTypes.Other\n}\n\nconst getKeyOfValue = (\n  v: unknown,\n  key: string | number,\n  vType: ValueTypes = getTypeOfValue(v),\n): unknown => {\n  if (vType === ValueTypes.Dict && typeof key === 'string') {\n    return (v as $IntentionalAny)[key]\n  } else if (vType === ValueTypes.Array && isValidArrayIndex(key)) {\n    return (v as $IntentionalAny)[key]\n  } else {\n    return undefined\n  }\n}\n\nconst isValidArrayIndex = (key: string | number): boolean => {\n  const inNumber = typeof key === 'number' ? key : parseInt(key, 10)\n  return (\n    !isNaN(inNumber) &&\n    inNumber >= 0 &&\n    inNumber < Infinity &&\n    (inNumber | 0) === inNumber\n  )\n}\n\nclass Scope {\n  children: Map<string | number, Scope> = new Map()\n  identityChangeListeners: Set<Listener> = new Set()\n  constructor(\n    readonly _parent: undefined | Scope,\n    readonly _path: (string | number)[],\n  ) {}\n\n  addIdentityChangeListener(cb: Listener) {\n    this.identityChangeListeners.add(cb)\n  }\n\n  removeIdentityChangeListener(cb: Listener) {\n    this.identityChangeListeners.delete(cb)\n    this._checkForGC()\n  }\n\n  removeChild(key: string | number) {\n    this.children.delete(key)\n    this._checkForGC()\n  }\n\n  getChild(key: string | number) {\n    return this.children.get(key)\n  }\n\n  getOrCreateChild(key: string | number) {\n    let child = this.children.get(key)\n    if (!child) {\n      child = child = new Scope(this, this._path.concat([key]))\n      this.children.set(key, child)\n    }\n    return child\n  }\n\n  _checkForGC() {\n    if (this.identityChangeListeners.size > 0) return\n    if (this.children.size > 0) return\n\n    if (this._parent) {\n      this._parent.removeChild(last(this._path) as string | number)\n    }\n  }\n}\n\n/**\n * Wraps an object whose (sub)properties can be individually tracked.\n */\nexport default class Atom<State extends {}>\n  implements IdentityDerivationProvider\n{\n  private _currentState: State\n  /**\n   * @internal\n   */\n  readonly $$isIdentityDerivationProvider = true\n  private readonly _rootScope: Scope\n  /**\n   * Convenience property that gives you a pointer to the root of the atom.\n   *\n   * @remarks\n   * Equivalent to `pointer({ root: thisAtom, path: [] })`.\n   */\n  readonly pointer: Pointer<State>\n\n  constructor(initialState: State) {\n    this._currentState = initialState\n    this._rootScope = new Scope(undefined, [])\n    this.pointer = pointer({root: this as $FixMe, path: []})\n  }\n\n  /**\n   * Sets the state of the atom.\n   *\n   * @param newState - The new state of the atom.\n   */\n  setState(newState: State) {\n    const oldState = this._currentState\n    this._currentState = newState\n\n    this._checkUpdates(this._rootScope, oldState, newState)\n  }\n\n  /**\n   * Gets the current state of the atom.\n   */\n  getState() {\n    return this._currentState\n  }\n\n  /**\n   * Gets the state of the atom at `path`.\n   */\n  getIn(path: (string | number)[]): unknown {\n    return path.length === 0 ? this.getState() : get(this.getState(), path)\n  }\n\n  /**\n   * Creates a new state object from the current one, where the value at `path`\n   * is replaced by the return value of `reducer`, then sets it.\n   *\n   * @remarks\n   * Doesn't mutate the old state, and preserves referential equality between\n   * values of the old state and the new state where possible.\n   *\n   * @example\n   * ```ts\n   * someAtom.getIn(['a']) // 1\n   * someAtom.reduceState(['a'], (state) => state + 1);\n   * someAtom.getIn(['a']) // 2\n   * ```\n   *\n   * @param path - The path to call the reducer at.\n   * @param reducer - The function to use for creating the new state.\n   */\n  // TODO: Why is this a property and not a method?\n  reduceState: PathBasedReducer<State, State> = (\n    path: $IntentionalAny[],\n    reducer: $IntentionalAny,\n  ) => {\n    const newState = updateDeep(this.getState(), path, reducer)\n    this.setState(newState)\n    return newState\n  }\n\n  /**\n   * Sets the state of the atom at `path`.\n   */\n  setIn(path: $FixMe[], val: $FixMe) {\n    return this.reduceState(path, () => val)\n  }\n\n  private _checkUpdates(scope: Scope, oldState: unknown, newState: unknown) {\n    if (oldState === newState) return\n    for (const cb of scope.identityChangeListeners) {\n      cb(newState)\n    }\n\n    if (scope.children.size === 0) return\n\n    // @todo we can probably skip checking value types\n    const oldValueType = getTypeOfValue(oldState)\n    const newValueType = getTypeOfValue(newState)\n\n    if (oldValueType === ValueTypes.Other && oldValueType === newValueType)\n      return\n\n    for (const [childKey, childScope] of scope.children) {\n      const oldChildVal = getKeyOfValue(oldState, childKey, oldValueType)\n      const newChildVal = getKeyOfValue(newState, childKey, newValueType)\n      this._checkUpdates(childScope, oldChildVal, newChildVal)\n    }\n  }\n\n  private _getOrCreateScopeForPath(path: (string | number)[]): Scope {\n    let curScope = this._rootScope\n    for (const pathEl of path) {\n      curScope = curScope.getOrCreateChild(pathEl)\n    }\n    return curScope\n  }\n\n  private _onPathValueChange = (\n    path: (string | number)[],\n    cb: (v: unknown) => void,\n  ) => {\n    const scope = this._getOrCreateScopeForPath(path)\n    scope.identityChangeListeners.add(cb)\n    const untap = () => {\n      scope.identityChangeListeners.delete(cb)\n    }\n    return untap\n  }\n\n  /**\n   * Returns a new derivation of the value at the provided path.\n   *\n   * @param path - The path to create the derivation at.\n   */\n  getIdentityDerivation(path: Array<string | number>): IDerivation<unknown> {\n    return new DerivationFromSource<$IntentionalAny>(\n      (listener) => this._onPathValueChange(path, listener),\n      () => this.getIn(path),\n    )\n  }\n}\n\nconst identityDerivationWeakMap = new WeakMap<{}, IDerivation<unknown>>()\n\n/**\n * Returns a derivation of the value at the provided pointer. Derivations are\n * cached per pointer.\n *\n * @param pointer - The pointer to return the derivation at.\n */\nexport const valueDerivation = <P extends PointerType<$IntentionalAny>>(\n  pointer: P,\n): IDerivation<P extends PointerType<infer T> ? T : void> => {\n  const meta = getPointerMeta(pointer)\n\n  let derivation = identityDerivationWeakMap.get(meta)\n  if (!derivation) {\n    const root = meta.root\n    if (!isIdentityDerivationProvider(root)) {\n      throw new Error(\n        `Cannot run valueDerivation() on a pointer whose root is not an IdentityChangeProvider`,\n      )\n    }\n    const {path} = meta\n    derivation = root.getIdentityDerivation(path)\n    identityDerivationWeakMap.set(meta, derivation)\n  }\n  return derivation as $IntentionalAny\n}\n\nfunction isIdentityDerivationProvider(\n  val: unknown,\n): val is IdentityDerivationProvider {\n  return (\n    typeof val === 'object' &&\n    val !== null &&\n    (val as $IntentionalAny)['$$isIdentityDerivationProvider'] === true\n  )\n}\n\n/**\n * Convenience function that returns a plain value from its argument, whether it\n * is a pointer, a derivation or a plain value itself.\n *\n * @remarks\n * For pointers, the value is returned by first creating a derivation, so it is\n * reactive e.g. when used in a `prism`.\n *\n * @param input - The argument to return a value from.\n */\nexport const val = <\n  P extends\n    | PointerType<$IntentionalAny>\n    | IDerivation<$IntentionalAny>\n    | undefined\n    | null,\n>(\n  input: P,\n): P extends PointerType<infer T>\n  ? T\n  : P extends IDerivation<infer T>\n  ? T\n  : P extends undefined | null\n  ? P\n  : unknown => {\n  if (isPointer(input)) {\n    return valueDerivation(input).getValue() as $IntentionalAny\n  } else if (isDerivation(input)) {\n    return input.getValue() as $IntentionalAny\n  } else {\n    return input as $IntentionalAny\n  }\n}\n", "import DerivationFromSource from './derivations/DerivationFromSource'\nimport type {IDerivation} from './derivations/IDerivation'\nimport Emitter from './utils/Emitter'\n\n/**\n * Common interface for Box types. Boxes wrap a single value.\n */\nexport interface IBox<V> {\n  /**\n   * Sets the value of the Box.\n   *\n   * @param v - The value to update the Box with.\n   */\n\n  set(v: V): void\n  /**\n   * Gets the value of the Box.\n   *\n   * @remarks\n   * Usages of `get()` aren't tracked, they are only for retrieving the value. To track changes, you need to\n   * create a derivation.\n   *\n   * @see derivation\n   */\n  get(): V\n\n  /**\n   * Creates a derivation of the Box that you can use to track changes to it.\n   */\n  derivation: IDerivation<V>\n}\n\n/**\n * Wraps a single value.\n *\n * @remarks\n * Derivations created with {@link Box.derivation} update based on strict equality (`===`) of the old value and the new one.\n * This also means that property-changes of objects won't be tracked, and that for objects, updates will trigger on changes of\n * reference even if the objects are structurally equal.\n */\nexport default class Box<V> implements IBox<V> {\n  private _publicDerivation: IDerivation<V>\n  private _emitter = new Emitter<V>()\n\n  /**\n   * @param _value - The initial value of the Box.\n   */\n  constructor(\n    /**\n     * @internal\n     */\n    protected _value: V,\n  ) {\n    this._publicDerivation = new DerivationFromSource(\n      (listener) => this._emitter.tappable.tap(listener),\n      this.get.bind(this),\n    )\n  }\n\n  /**\n   * Sets the value of the Box.\n   *\n   * @param v - The value to update the Box with.\n   */\n  set(v: V) {\n    if (v === this._value) return\n    this._value = v\n    this._emitter.emit(v)\n  }\n\n  /**\n   * Gets the value of the Box.\n   *\n   * Note: usages of `get()` aren't tracked, they are only for retrieving the value. To track changes, you need to\n   * create a derivation.\n   *\n   * @see Box.derivation\n   */\n  get() {\n    return this._value\n  }\n\n  /**\n   * Creates a derivation of the Box that you can use to track changes to it.\n   */\n  get derivation() {\n    return this._publicDerivation\n  }\n}\n", "import AbstractDerivation from './AbstractDerivation'\n\n/**\n * A derivation whose value never changes.\n */\nexport default class ConstantDerivation<V> extends AbstractDerivation<V> {\n  private readonly _v: V\n\n  /**\n   * @param v - The value of the derivation.\n   */\n  constructor(v: V) {\n    super()\n    this._v = v\n    return this\n  }\n\n  /**\n   * @internal\n   */\n  _recalculate() {\n    return this._v\n  }\n\n  /**\n   * @internal\n   */\n  _reactToDependencyBecomingStale() {}\n}\n", "import {valueDerivation} from '../Atom'\nimport type {Pointer} from '../pointer'\nimport {isPointer} from '../pointer'\nimport type {IDerivation} from './IDerivation'\nimport {isDerivation} from './IDerivation'\n\nexport default function* iterateAndCountTicks<V>(\n  pointerOrDerivation: IDerivation<V> | Pointer<V>,\n): Generator<{value: V; ticks: number}, void, void> {\n  let d\n  if (isPointer(pointerOrDerivation)) {\n    d = valueDerivation(pointerOrDerivation) as IDerivation<V>\n  } else if (isDerivation(pointerOrDerivation)) {\n    d = pointerOrDerivation\n  } else {\n    throw new Error(`Only pointers and derivations are supported`)\n  }\n\n  let ticksCountedSinceLastYield = 0\n  const untap = d.changesWithoutValues().tap(() => {\n    ticksCountedSinceLastYield++\n  })\n\n  try {\n    while (true) {\n      const ticks = ticksCountedSinceLastYield\n      ticksCountedSinceLastYield = 0\n      yield {value: d.getValue(), ticks}\n    }\n  } finally {\n    untap()\n  }\n}\n", "type ICallback = (t: number) => void\n\nfunction createRafTicker() {\n  const ticker = new Ticker()\n\n  if (typeof window !== 'undefined') {\n    /**\n     * @remarks\n     * TODO users should also be able to define their own ticker.\n     */\n    const onAnimationFrame = (t: number) => {\n      ticker.tick(t)\n      window.requestAnimationFrame(onAnimationFrame)\n    }\n    window.requestAnimationFrame(onAnimationFrame)\n  } else {\n    ticker.tick(0)\n    setTimeout(() => ticker.tick(1), 0)\n    console.log(\n      `@theatre/dataverse is running in a server rather than in a browser. We haven't gotten around to testing server-side rendering, so if something is working in the browser but not on the server, please file a bug: https://github.com/theatre-js/theatre/issues/new`,\n    )\n  }\n\n  return ticker\n}\n\nlet rafTicker: undefined | Ticker\n\n/**\n * The Ticker class helps schedule callbacks. Scheduled callbacks are executed per tick. Ticks can be triggered by an\n * external scheduling strategy, e.g. a raf.\n */\nexport default class Ticker {\n  /** Get a shared `requestAnimationFrame` ticker. */\n  static get raf(): Ticker {\n    if (!rafTicker) {\n      rafTicker = createRafTicker()\n    }\n    return rafTicker\n  }\n  private _scheduledForThisOrNextTick: Set<ICallback>\n  private _scheduledForNextTick: Set<ICallback>\n  private _timeAtCurrentTick: number\n  private _ticking: boolean = false\n  /**\n   * Counts up for every tick executed.\n   * Internally, this is used to measure ticks per second.\n   *\n   * This is \"public\" to TypeScript, because it's a tool for performance measurements.\n   * Consider this as experimental, and do not rely on it always being here in future releases.\n   */\n  public __ticks = 0\n\n  constructor() {\n    this._scheduledForThisOrNextTick = new Set()\n    this._scheduledForNextTick = new Set()\n    this._timeAtCurrentTick = 0\n  }\n\n  /**\n   * Registers for fn to be called either on this tick or the next tick.\n   *\n   * If `onThisOrNextTick()` is called while `Ticker.tick()` is running, the\n   * side effect _will_ be called within the running tick. If you don't want this\n   * behavior, you can use `onNextTick()`.\n   *\n   * Note that `fn` will be added to a `Set()`. Which means, if you call `onThisOrNextTick(fn)`\n   * with the same fn twice in a single tick, it'll only run once.\n   *\n   * @param fn - The function to be registered.\n   *\n   * @see offThisOrNextTick\n   */\n  onThisOrNextTick(fn: ICallback) {\n    this._scheduledForThisOrNextTick.add(fn)\n  }\n\n  /**\n   * Registers a side effect to be called on the next tick.\n   *\n   * @param fn - The function to be registered.\n   *\n   * @see onThisOrNextTick\n   * @see offNextTick\n   */\n  onNextTick(fn: ICallback) {\n    this._scheduledForNextTick.add(fn)\n  }\n\n  /**\n   * De-registers a fn to be called either on this tick or the next tick.\n   *\n   * @param fn - The function to be de-registered.\n   *\n   * @see onThisOrNextTick\n   */\n  offThisOrNextTick(fn: ICallback) {\n    this._scheduledForThisOrNextTick.delete(fn)\n  }\n\n  /**\n   * De-registers a fn to be called on the next tick.\n   *\n   * @param fn - The function to be de-registered.\n   *\n   * @see onNextTick\n   */\n  offNextTick(fn: ICallback) {\n    this._scheduledForNextTick.delete(fn)\n  }\n\n  /**\n   * The time at the start of the current tick if there is a tick in progress, otherwise defaults to\n   * `performance.now()`.\n   */\n  get time() {\n    if (this._ticking) {\n      return this._timeAtCurrentTick\n    } else return performance.now()\n  }\n\n  /**\n   * Triggers a tick which starts executing the callbacks scheduled for this tick.\n   *\n   * @param t - The time at the tick.\n   *\n   * @see onThisOrNextTick\n   * @see onNextTick\n   */\n  tick(t: number = performance.now()) {\n    if (process.env.NODE_ENV === 'development') {\n      if (!(this instanceof Ticker)) {\n        throw new Error(\n          'ticker.tick must be called while bound to the ticker. As in, \"ticker.tick(time)\" or \"requestAnimationFrame((t) => ticker.tick(t))\" for performance.',\n        )\n      }\n    }\n\n    this.__ticks++\n\n    this._ticking = true\n    this._timeAtCurrentTick = t\n    for (const v of this._scheduledForNextTick) {\n      this._scheduledForThisOrNextTick.add(v)\n    }\n\n    this._scheduledForNextTick.clear()\n    this._tick(0)\n    this._ticking = false\n  }\n\n  private _tick(iterationNumber: number): void {\n    const time = this.time\n\n    if (iterationNumber > 10) {\n      console.warn('_tick() recursing for 10 times')\n    }\n\n    if (iterationNumber > 100) {\n      throw new Error(`Maximum recursion limit for _tick()`)\n    }\n\n    const oldSet = this._scheduledForThisOrNextTick\n    this._scheduledForThisOrNextTick = new Set()\n    for (const fn of oldSet) {\n      fn(time)\n    }\n\n    if (this._scheduledForThisOrNextTick.size > 0) {\n      return this._tick(iterationNumber + 1)\n    }\n  }\n}\n", "import {valueDerivation} from '../Atom'\nimport type {Pointer} from '../pointer'\nimport {isPointer} from '../pointer'\nimport Ticker from '../Ticker'\nimport type {IDerivation} from './IDerivation'\nimport {isDerivation} from './IDerivation'\n\nexport default function* iterateOver<V>(\n  pointerOrDerivation: IDerivation<V> | Pointer<V>,\n): Generator<V, void, void> {\n  let d\n  if (isPointer(pointerOrDerivation)) {\n    d = valueDerivation(pointerOrDerivation) as IDerivation<V>\n  } else if (isDerivation(pointerOrDerivation)) {\n    d = pointerOrDerivation\n  } else {\n    throw new Error(`Only pointers and derivations are supported`)\n  }\n\n  const ticker = new Ticker()\n\n  const untap = d.changes(ticker).tap((v) => {})\n\n  try {\n    while (true) {\n      ticker.tick()\n\n      yield d.getValue()\n    }\n  } finally {\n    untap()\n  }\n}\n", "import Box from '../../Box'\nimport type {$IntentionalAny, VoidFn} from '../../types'\nimport Stack from '../../utils/Stack'\nimport AbstractDerivation from '../AbstractDerivation'\nimport type {IDerivation} from '../IDerivation'\nimport {\n  startIgnoringDependencies,\n  stopIgnoringDependencies,\n  pushCollector,\n  popCollector,\n} from './discoveryMechanism'\n\nconst voidFn = () => {}\n\nexport class PrismDerivation<V> extends AbstractDerivation<V> {\n  protected _cacheOfDendencyValues: Map<IDerivation<unknown>, unknown> =\n    new Map()\n  protected _possiblyStaleDeps = new Set<IDerivation<unknown>>()\n  private _prismScope = new PrismScope()\n\n  constructor(readonly _fn: () => V) {\n    super()\n  }\n\n  _recalculate() {\n    let value: V\n\n    if (this._possiblyStaleDeps.size > 0) {\n      let anActuallyStaleDepWasFound = false\n      startIgnoringDependencies()\n      for (const dep of this._possiblyStaleDeps) {\n        if (this._cacheOfDendencyValues.get(dep) !== dep.getValue()) {\n          anActuallyStaleDepWasFound = true\n          break\n        }\n      }\n      stopIgnoringDependencies()\n      this._possiblyStaleDeps.clear()\n      if (!anActuallyStaleDepWasFound) {\n        // console.log('ok')\n\n        return this._lastValue!\n      }\n    }\n\n    const newDeps: Set<IDerivation<unknown>> = new Set()\n    this._cacheOfDendencyValues.clear()\n\n    const collector = (observedDep: IDerivation<unknown>): void => {\n      newDeps.add(observedDep)\n      this._addDependency(observedDep)\n    }\n\n    pushCollector(collector)\n\n    hookScopeStack.push(this._prismScope)\n    try {\n      value = this._fn()\n    } catch (error) {\n      console.error(error)\n    } finally {\n      const topOfTheStack = hookScopeStack.pop()\n      if (topOfTheStack !== this._prismScope) {\n        console.warn(\n          // @todo guide the user to report the bug in an issue\n          `The Prism hook stack has slipped. This is a bug.`,\n        )\n      }\n    }\n\n    popCollector(collector)\n\n    for (const dep of this._dependencies) {\n      if (!newDeps.has(dep)) {\n        this._removeDependency(dep)\n      }\n    }\n\n    this._dependencies = newDeps\n\n    startIgnoringDependencies()\n    for (const dep of newDeps) {\n      this._cacheOfDendencyValues.set(dep, dep.getValue())\n    }\n    stopIgnoringDependencies()\n\n    return value!\n  }\n\n  _reactToDependencyBecomingStale(msgComingFrom: IDerivation<unknown>) {\n    this._possiblyStaleDeps.add(msgComingFrom)\n  }\n\n  _keepHot() {\n    this._prismScope = new PrismScope()\n    startIgnoringDependencies()\n    this.getValue()\n    stopIgnoringDependencies()\n  }\n\n  _becomeCold() {\n    cleanupScopeStack(this._prismScope)\n    this._prismScope = new PrismScope()\n  }\n}\n\nclass PrismScope {\n  isPrismScope = true\n  private _subs: Record<string, PrismScope> = {}\n\n  sub(key: string) {\n    if (!this._subs[key]) {\n      this._subs[key] = new PrismScope()\n    }\n    return this._subs[key]\n  }\n\n  get subs() {\n    return this._subs\n  }\n}\n\nfunction cleanupScopeStack(scope: PrismScope) {\n  for (const sub of Object.values(scope.subs)) {\n    cleanupScopeStack(sub)\n  }\n  cleanupEffects(scope)\n}\n\nfunction cleanupEffects(scope: PrismScope) {\n  const effects = effectsWeakMap.get(scope)\n  if (effects) {\n    for (const effect of effects.values()) {\n      safelyRun(effect.cleanup, undefined)\n    }\n  }\n  effectsWeakMap.delete(scope)\n}\n\nfunction safelyRun<T, U>(\n  fn: () => T,\n  returnValueInCaseOfError: U,\n): {ok: true; value: T} | {ok: false; value: U} {\n  try {\n    return {value: fn(), ok: true}\n  } catch (error) {\n    // Naming this function can allow the error reporter additional context to the user on where this error came from\n    setTimeout(function PrismReportThrow() {\n      // ensure that the error gets reported, but does not crash the current execution scope\n      throw error\n    })\n    return {value: returnValueInCaseOfError, ok: false}\n  }\n}\n\nconst hookScopeStack = new Stack<PrismScope>()\n\nconst refsWeakMap = new WeakMap<PrismScope, Map<string, IRef<unknown>>>()\n\ntype IRef<T> = {\n  current: T\n}\nconst effectsWeakMap = new WeakMap<PrismScope, Map<string, IEffect>>()\n\ntype IEffect = {\n  deps: undefined | unknown[]\n  cleanup: VoidFn\n}\n\nconst memosWeakMap = new WeakMap<PrismScope, Map<string, IMemo>>()\n\ntype IMemo = {\n  deps: undefined | unknown[] | ReadonlyArray<unknown>\n  cachedValue: unknown\n}\n\nfunction ref<T>(key: string, initialValue: T): IRef<T> {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.ref() is called outside of a prism() call.`)\n  }\n  let refs = refsWeakMap.get(scope)\n  if (refs === undefined) {\n    refs = new Map()\n    refsWeakMap.set(scope, refs)\n  }\n\n  let ref = refs.get(key)\n  if (ref !== undefined) {\n    return ref as $IntentionalAny as IRef<T>\n  } else {\n    const ref = {\n      current: initialValue,\n    }\n    refs.set(key, ref)\n    return ref\n  }\n}\n\n/**\n * An effect hook, similar to React's `useEffect()`, but is not sensitive to call order by using `key`.\n *\n * @param key - the key for the effect. Should be uniqe inside of the prism.\n * @param cb - the callback function. Requires returning a cleanup function.\n * @param deps - the dependency array\n */\nfunction effect(key: string, cb: () => () => void, deps?: unknown[]): void {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.effect() is called outside of a prism() call.`)\n  }\n  let effects = effectsWeakMap.get(scope)\n\n  if (effects === undefined) {\n    effects = new Map()\n    effectsWeakMap.set(scope, effects)\n  }\n\n  let effect = effects.get(key)\n  if (effect === undefined) {\n    effect = {\n      cleanup: voidFn,\n      deps: undefined,\n    }\n    effects.set(key, effect)\n  }\n\n  if (depsHaveChanged(effect.deps, deps)) {\n    effect.cleanup()\n\n    startIgnoringDependencies()\n    effect.cleanup = safelyRun(cb, voidFn).value\n    stopIgnoringDependencies()\n    effect.deps = deps\n  }\n}\n\nfunction depsHaveChanged(\n  oldDeps: undefined | unknown[] | ReadonlyArray<unknown>,\n  newDeps: undefined | unknown[] | ReadonlyArray<unknown>,\n): boolean {\n  if (oldDeps === undefined || newDeps === undefined) {\n    return true\n  }\n\n  const len = oldDeps.length\n  if (len !== newDeps.length) return true\n\n  for (let i = 0; i < len; i++) {\n    if (oldDeps[i] !== newDeps[i]) return true\n  }\n\n  return false\n}\n\n/**\n * Store a value to this {@link prism} stack.\n *\n * Unlike hooks seen in popular frameworks like React, you provide an exact `key` so\n * we can call `prism.memo` in any order, and conditionally.\n *\n * @param deps - Passing in `undefined` will always cause a recompute\n */\nfunction memo<T>(\n  key: string,\n  fn: () => T,\n  deps: undefined | $IntentionalAny[] | ReadonlyArray<$IntentionalAny>,\n): T {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.memo() is called outside of a prism() call.`)\n  }\n\n  let memos = memosWeakMap.get(scope)\n\n  if (!memos) {\n    memos = new Map()\n    memosWeakMap.set(scope, memos)\n  }\n\n  let memo = memos.get(key)\n  if (memo === undefined) {\n    memo = {\n      cachedValue: null,\n      // undefined will always indicate \"deps have changed\", so we set it's initial value as such\n      deps: undefined,\n    }\n    memos.set(key, memo)\n  }\n\n  if (depsHaveChanged(memo.deps, deps)) {\n    startIgnoringDependencies()\n\n    memo.cachedValue = safelyRun(fn, undefined).value\n    stopIgnoringDependencies()\n    memo.deps = deps\n  }\n\n  return memo.cachedValue as $IntentionalAny as T\n}\n\n/**\n * A state hook, similar to react's `useState()`.\n *\n * @param key - the key for the state\n * @param initialValue - the initial value\n * @returns [currentState, setState]\n *\n * @example\n * ```ts\n * import {prism} from 'dataverse'\n *\n * // This derivation holds the current mouse position and updates when the mouse moves\n * const mousePositionD = prism(() => {\n *   const [pos, setPos] = prism.state<[x: number, y: number]>('pos', [0, 0])\n *\n *   prism.effect(\n *     'setupListeners',\n *     () => {\n *       const handleMouseMove = (e: MouseEvent) => {\n *         setPos([e.screenX, e.screenY])\n *       }\n *       document.addEventListener('mousemove', handleMouseMove)\n *\n *       return () => {\n *         document.removeEventListener('mousemove', handleMouseMove)\n *       }\n *     },\n *     [],\n *   )\n *\n *   return pos\n * })\n * ```\n */\nfunction state<T>(key: string, initialValue: T): [T, (val: T) => void] {\n  const {b, setValue} = prism.memo(\n    'state/' + key,\n    () => {\n      const b = new Box<T>(initialValue)\n      const setValue = (val: T) => b.set(val)\n      return {b, setValue}\n    },\n    [],\n  )\n\n  return [b.derivation.getValue(), setValue]\n}\n\n/**\n * This is useful to make sure your code is running inside a `prism()` call.\n *\n * @example\n * ```ts\n * import {prism} from '@theatre/dataverse'\n *\n * function onlyUsefulInAPrism() {\n *   prism.ensurePrism()\n * }\n *\n * prism(() => {\n *   onlyUsefulInAPrism() // will run fine\n * })\n *\n * setTimeout(() => {\n *   onlyUsefulInAPrism() // throws an error\n *   console.log('This will never get logged')\n * }, 0)\n * ```\n */\nfunction ensurePrism(): void {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`The parent function is called outside of a prism() call.`)\n  }\n}\n\nfunction scope<T>(key: string, fn: () => T): T {\n  const parentScope = hookScopeStack.peek()\n  if (!parentScope) {\n    throw new Error(`prism.scope() is called outside of a prism() call.`)\n  }\n  const subScope = parentScope.sub(key)\n  hookScopeStack.push(subScope)\n  const ret = safelyRun(fn, undefined).value\n  hookScopeStack.pop()\n  return ret as $IntentionalAny as T\n}\n\nfunction sub<T>(\n  key: string,\n  fn: () => T,\n  deps: undefined | $IntentionalAny[],\n): T {\n  return memo(key, () => prism(fn), deps).getValue()\n}\n\nfunction inPrism(): boolean {\n  return !!hookScopeStack.peek()\n}\n\ntype IPrismFn = {\n  <T>(fn: () => T): IDerivation<T>\n  ref: typeof ref\n  effect: typeof effect\n  memo: typeof memo\n  ensurePrism: typeof ensurePrism\n  state: typeof state\n  scope: typeof scope\n  sub: typeof sub\n  inPrism: typeof inPrism\n}\n\n/**\n * Creates a derivation from the passed function that adds all derivations referenced\n * in it as dependencies, and reruns the function when these change.\n *\n * @param fn - The function to rerun when the derivations referenced in it change.\n */\nconst prism: IPrismFn = (fn) => {\n  return new PrismDerivation(fn)\n}\n\nprism.ref = ref\nprism.effect = effect\nprism.memo = memo\nprism.ensurePrism = ensurePrism\nprism.state = state\nprism.scope = scope\nprism.sub = sub\nprism.inPrism = inPrism\n\nexport default prism\n", "import type {IdentityDerivationProvider} from './Atom'\nimport type {Pointer} from './pointer'\nimport pointer from './pointer'\nimport type {IBox} from './Box'\nimport Box from './Box'\nimport type {$FixMe, $IntentionalAny} from './types'\nimport {valueDerivation} from './Atom'\n\n/**\n * Allows creating pointer-derivations where the pointer can be switched out.\n *\n * @remarks\n * This allows reacting not just to value changes at a certain pointer, but changes\n * to the proxied pointer too.\n */\nexport default class PointerProxy<O extends {}>\n  implements IdentityDerivationProvider\n{\n  /**\n   * @internal\n   */\n  readonly $$isIdentityDerivationProvider = true\n  private readonly _currentPointerBox: IBox<Pointer<O>>\n  /**\n   * Convenience pointer pointing to the root of this PointerProxy.\n   *\n   * @remarks\n   * Allows convenient use of {@link valueDerivation} and {@link val}.\n   */\n  readonly pointer: Pointer<O>\n\n  constructor(currentPointer: Pointer<O>) {\n    this._currentPointerBox = new Box(currentPointer)\n    this.pointer = pointer({root: this as $FixMe, path: []})\n  }\n\n  /**\n   * Sets the underlying pointer.\n   * @param p - The pointer to be proxied.\n   */\n  setPointer(p: Pointer<O>) {\n    this._currentPointerBox.set(p)\n  }\n\n  /**\n   * Returns a derivation of the value at the provided sub-path of the proxied pointer.\n   *\n   * @param path - The path to create the derivation at.\n   */\n  getIdentityDerivation(path: Array<string | number>) {\n    return this._currentPointerBox.derivation.flatMap((p) => {\n      const subPointer = path.reduce(\n        (pointerSoFar, pathItem) => (pointerSoFar as $IntentionalAny)[pathItem],\n        p,\n      )\n      return valueDerivation(subPointer)\n    })\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
